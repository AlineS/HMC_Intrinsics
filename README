--------------------------------------------------------------------------------
-
- Aline Santana Cordeiro - ascordeiro@inf.ufpr.br
- LSE - Embedded Sistems Laboratory - 2018
- PPGInf - Federal University of Paran√°
-
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-                               Intrinsics Library                             -
--------------------------------------------------------------------------------
-
-   The Intrinsics-HMC and Intrinsics-MIPS Libraries were developed to simulate
- the ISA's execution of Hybrid Memory Cube (HMC), described in HMC 2.1
- specification (http://www.hybridmemorycube.org), and MIPS. The mainly purpose
- is to write a C or C++ program using these libraries generate a trace that
- simulates the program's execution in one of these architectures. This task
- can be achieved by using the program's binary file as SiNUCA-tracer entry,
- that interprets the libraries instructions and generate the traces in a
- simulation specific format.
-
--------------------------------------------------------------------------------
-
- DATA TYPES -
-
- HMC:
- __h16u1:  16-bit unsigned integer;
- __h64u1:  64-bit unsigned integer;
- __h64u2:  Two 64-bit unsigned integers in a vector;
- __h128u1: 128-bit unsigned integer;
-
- MIPS:
- __m32s1: 32-bit signed integer;
- __m32u1: 32-bit unsigned integer;
- __m64s1: 64-bit signed integer;
- __m64u1: 64-bit unsigned integer;
-
- HIVE:
- __hi32s: 32-bit signed integer;
- __hi32u: 32-bit unsigned integer;
- __hi64s: 64-bit signed integer;
- __hi64u: 64-bit unsigned integer;
-
-   The data types were renamed inspired in Intel Intrinsics function pattern.
- Which identifies the intrinsics data type is the first 2 underlines
- characteres. The third (and fouth for HIVE) character(s) identify the choosen
- architechture. The next 2 characteres indicates the variable size in bits.
- The next charactere indicates if is a signed or unsigned number. For HMC and
- MIPS, the last one indicates the number of variables assigned to that type
- (As HIVE is an vectorized instruction, the instruction lenght is assigned to
- instruction name).
-
--------------------------------------------------------------------------------
-
-------------------------------- HMC FUNCTIONS ---------------------------------
-
- The implementation is based on HMC 2.1 specification and does not follows
- exactly the real behave described in the specification.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Dual 8-Byte Signed Add Immediate:
- __h64u2 *_hmc64_saddimm_d(__h64u2 *mem_op, __h64u2 *imm_op)
- Sums two memory operands with two immediate operands (8-byte). The operands
- must have 4-bytes size and must be in two-complement with left zeroes padding
- (4-byte). The result is returned to the call function.
-
- Single 16-Byte Signed Add Immediate:
- __h128u1 _hmc128_saddimm_s(__h128u1 *mem_op, __h128u1 *imm_op)
- Sums a memory operand (16-byte) with an immediate operand in two-complement
- with left zeroes padding (16-byte). The result is returned to the call
- function.
-
- 8-Byte Increment:
- __h64u1 _hmc64_incr_s(__h64u1 *mem_op)
- Increments a memory operand (8-byte) in one unity. The result is returned to
- the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Bit Write:
- __h64u1 _hmc64_bwrite_s(__h64u1 mem_op, __h64u1 imm_op, __h64u1 mask)
- The mask field (8-Byte) selects which immediate operand bits (8-byte) must be
- written in the same positions of memory operand (8-Byte). The result is
- returned to the call function.
-
- 16-Byte Swap:
- __h128u1 _hmc128_bswap_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the immediate operand value into the memory operand address (16-Byte).
- Returns the original memory operand value (16-Byte).
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- BOOLEAN:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 16-Byte AND:
- __h128u1 _hmc128_and_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the AND operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte NAND:
- __h128u1 _hmc128_nand_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the NAND operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte NOR:
- __h128u1 _hmc128_nor_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the NOR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte OR:
- __h128u1 _hmc128_or_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the OR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte)  into the memory operand address. Returns the
- original memory operand value.
-
- 16-Byte XOR:
- __h128u1 _hmc128_xor_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores the XOR operation's result between the memory operand (16-byte) and
- immediate operand (16-byte) into the memory operand address. Returns the
- original memory operand value.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Compare and Swap if Greater Than:
- __h128u1 _hmc64_cmpswapgt_s(__h64u1 mem_op, __h64u1 imm_op)
- Stores into the memory operand address the greater value between the memory
- operand (8-byte) and immediate operand (8-byte). Returns the original memory
- operand value.
-
- 8-Byte Compare and Swap if Less Than:
- __h128u1 _hmc64_cmpswaplt_s(__h64u1 mem_op, __h64u1 imm_op)
- Stores into the memory operand address the smaller value between the memory
- operand (8-byte) and immediate operand (8-byte). Returns the original memory
- operand value.
-
- 16-Byte Compare and Swap if Greater Than:
- __h128u1 _hmc128_cmpswapgt_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores into the memory operand address the greater value between the memory
- operand (16-byte) and immediate operand (16-byte). Returns the original memory
- operand value.
-
- 16-Byte Compare and Swap if Less Than:
- __h128u1 _hmc128_cmpswaplt_s(__h128u1 mem_op, __h128u1 imm_op)
- Stores into the memory operand address the smaller value between the memory
- operand (16-byte) and immediate operand (16-byte). Returns the original memory
- operand value.
-
- 8-Byte Compare and Swap if Equal:
- __h64u1 _hmc64_cmpswapeq_s(__h64u1 mem_op, __h64u1 imm_op, __h64u1 cmp_field)
- Compares the cmp_field (8-byte) with memory operand value (8-byte). If equal,
- stores the immediate operand value (8-byte) into the memory operand address.
- Returns the original memory operand value.
-
- 16-Byte Compare and Swap if Zero:
- __h128u1 _hmc128_cmpswapz_s(__h128u1 mem_op, __h128u1 imm_op)
- Compares the memory operand value (16-byte) with zero. If equal, stores the
- immediate operand value (16-byte) into the memory operand address. Returns
- the original memory operand value.
-
- 8-Byte Equal To:
- __h16u1 _hmc64_cmpswapgt_s(__h64u1 mem_op, __h64u1 imm_op)
- Verifies is the memory operand value (8-byte) is equal to the immediate
- operand value (8-byte). Returns 1 if equal, 0 if not.
-
- 16-Byte Equal To:
- __h16u1 _hmc128_cmpswapgt_s(__h128u1 mem_op, __h128u1 imm_op)
- Verifies is the memory operand value (16-byte) is equal to the immediate
- operand value (16-byte). Returns 1 if equal, 0 if not.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- CUSTOMIZED:
- These instructions were created to fit better in usual programming problems.
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 8-Byte Compare if Greater Than or equal:
- __h16u1 _hmc64_cmpgteq_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is minor or equal to the immediate
- operand value. If true, returns 0 to the call function, otherwise, returns 1.
-
- 8-Byte Compare if Less Than or equal:
- __h16u1 _hmc64_cmplteq_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is greater or equal to the immediate
- operand value. If true, returns 0 to the call function, otherwise, returns 1.
-
- 8-Byte Compare if Less Than:
- __h16u1 _hmc64_cmplt_s(__h64u1 *mem_op, __h64u1 imm_op)
- Verifies if the memory operand value is greater than the immediate operand
- value. If true, returns 0 to the call function, otherwise, returns 1.
-
--------------------------------------------------------------------------------
-
-------------------------------- MIPS FUNCTIONS --------------------------------
-
- The implementation is based on MIPS ISA and does not follows exactly the real
- behave of the architechture. All the instructions were implemented, except
- memory and floating point operations.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Add:
- __m32s1 _mips_add(__m32s1 rs, __m32s1 rt)
- Sums the rs and rt registers and returns the result to the call function.
-
- Add Unsigned:
- __m32u1 _mips_addu(__m32u1 rs, __m32u1 rt)
- Sums the rs and rt registers and returns the result to the call function.
-
- Subtract:
- __m32s1 _mips_sub(__m32s1 rs, __m32s1 rt)
- Subtracts the rs and rt registers and returns the result to the call function.
-
- Subtract Unsigned:
- __m32u1 _mips_subu(__m32u1 rs, __m32u1 rt)
- Subtracts the rs and rt registers and returns the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Add Immediate:
- __m32s1 _mips_addi(__m32s1 rs, __m32s1 imm_op)
- Sums the rs register and immediate operand and returns the result to the call
- function.
-
- Add Immediate Unsigned:
- __m32u1 _mips_addiu(__m32u1 rs, __m32u1 imm_op)
- Sums the rs register and immediate operand and returns the result to the call
- function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- And:
- __m32u1 _mips_and(__m32u1 rs, __m32u1 rt)
- Applies the AND operation between the rs and rt registers and returns the
- result to the call function.
-
- Nor:
- __m32u1 _mips_nor(__m32u1 rs, __m32u1 rt)
- Applies the NOR operation between the rs and rt registers and returns the
- result to the call function.
-
- Or:
- __m32u1 _mips_or(__m32u1 rs, __m32u1 rt)
- Applies the OR operation between the rs and rt registers and returns the
- result to the call function.
-
- Xor:
- __m32u1 _mips_xor(__m32u1 rs, __m32u1 rt)
- Applies the XOR operation between the rs and rt registers and returns the
- result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- And Immediate:
- __m32u1 _mips_andi(__m32u1 rs, __m32u1 imm_op)
- Applies the AND operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- Or Immediate:
- __m32u1 _mips_ori(__m32u1 rs, __m32u1 imm_op)
- Applies the OR operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- Xor Immediate:
- __m32u1 _mips_xori(__m32u1 rs, __m32u1 imm_op)
- Applies the XOR operation between the rs registers and immediate operand and
- returns the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Set Less Than:
- __m32s1 _mips_slt(__m32s1 rs, __m32s1 rt)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- Set Less Than Unsigned:
- __m32u1 _mips_sltu(__m32u1 rs, __m32u1 rt)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Set Less Than Immediate:
- __m32s1 _mips_slti(__m32s1 rs, __m32s1 imm_op)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- Set Less Than Immediate Unsigned:
- __m32u1 _mips_sltiu(__m32u1 rs, __m32u1 imm_op)
- Compares the rs and rt registers. Returns 1 if rs is minor than rt.
- 0, otherwise.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- SHIFT:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Shift Left Logical:
- __m32u1 _mips_sll(__m32u1 rt, __m32u1 shamt)
- Shifts to the left the shamt value in rt register. Returns the result to the
- call function.
-
- Shift Right Logical:
- __m32u1 _mips_srl(__m32u1 rt, __m32u1 shamt)
- Shifts to the right the shamt value in rt register. Returns the result to the
- call function.
-
- Shift Right Arithmetic:
- __m32s1 _mips_sra(__m32s1 rt, __m32s1 shamt)
- Shifts to the right the shamt value in rt register keeping rt signal. Returns
- the result to the call function.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- MULTIPLICATION/DIVISION:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- Divide Only:
- __m32s1 _mips_div(__m32s1 rs, __m32s1 rt)
- Returns to the call function the division between rs and rt registers.
-
- Divide Only Unsigned:
- __m32u1 _mips_divu(__m32u1 rs, __m32u1 rt)
- Returns to the call function the division between rs and rt registers.
-
- Module Only:
- __m32s1 _mips_mod(__m32s1 rs, __m32s1 rt)
- Returns to the call function the module operation between rs and rt registers.
-
- Module Only Unsigned:
- __m32u1 _mips_modu(__m32u1 rs, __m32u1 rt)
- Returns to the call function the module operation between rs and rt registers.
-
- Multiply 32-bits:
- __m32s1 _mips_mult32(__m32s1 rs, __m32s1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 32-bits Unsigned:
- __m32u1 _mips_multu32(__m32u1 rs, __m32u1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 64-bits:
- __m64s1 _mips_mult64(__m32s1 rs, __m32s1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
- Multiply 64-bits Unsigned:
- __m64u1 _mips_multu64(__m32u1 rs, __m32u1 rt)
- Multiplies the rs and rt registers and return the result to the call function.
-
--------------------------------------------------------------------------------
-
-------------------------------- HIVE FUNCTIONS --------------------------------
-
- The implementation is based on MIPS and ARM NEON specification and does not
- follows exactly the real behave described in these specifications. As HIVE
- implements vectorized instructions, the vector size is specified below.
-
- HI64I: 256-bytes array size to integer types;
- HI2KI: 8-Kbytes arrey size to integer types;
- HI32L: 256-bytes array size to long integer types;
- HI1KL: 8-Kbytes array size to long integer types;
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ARITHMETIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Add (64 integers):
- _hive64_adds(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed addition between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Add (2048 integers):
- _hive2K_adds(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed addition between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Add Unsigned (64 integers):
- _hive64_addu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned addition between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Add Unsigned (2048 integers):
- _hive2K_addu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned addition between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Subtract (64 integers):
- _hive64_subs(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed subtraction between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Subtract (2048 integers):
- _hive2K_subs(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed subtraction between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Subtract Unsigned (64 integers):
- _hive64_subu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned subtraction between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Subtract Unsigned (2048 integers):
- _hive2K_subu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned subtraction between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Abs (64 integers):
- _hive64_abs(__hi32s *a, __hi32s *b)
- Takes the absolute value of each element in a source vector A and stores it
- into the destination vector B.
-
- 32-bit Abs (2048 integers):
- _hive2K_abs(__hi32s *a, __hi32s *b)
- Takes the absolute value of each element in a source vector A and stores it
- into the destination vector B.
-
- 32-bit Max (64 integers):
- _hive64_max(__hi32s *a, __hi32s *b, __hi32s *c)
- Find the maximal value between each element of source vectors A and B and
- stores it into the destination vector C.
-
- 32-bit Max (2048 integers):
- _hive2K_max(__hi32s *a, __hi32s *b, __hi32s *c)
- Find the maximal value between each element of source vectors A and B and
- stores it into the destination vector C.
-
- 32-bit Min (64 integers):
- _hive64_min(__hi32s *a, __hi32s *b, __hi32s *c)
- Find the minimal value between each element of source vectors A and B and
- stores it into the destination vector C.
-
- 32-bit Min (2048 integers):
- _hive2K_min(__hi32s *a, __hi32s *b, __hi32s *c)
- Find the minimal value between each element of source vectors A and B and
- stores it into the destination vector C.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- LOGIC:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit And (64 integers):
- _hive64_and(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs AND operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit And (2048 integers):
- _hive2K_and(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs AND operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit Or (64 integers):
- _hive64_or(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs OR operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit Or (2048 integers):
- _hive2K_or(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs OR operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit Xor (64 integers):
- _hive64_xor(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs XOR operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit Xor (2048 integers):
- _hive2K_xor(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs XOR operation between elements of source vectors A and B and stores
- the result into the destination vector C.
-
- 32-bit Not (64 integers):
- _hive64_not(__hi32s *a, __hi32s *b)
- Performs NOT operation in elements of source vector A and stores the result
- into the destination vector B.
-
- 32-bit Not (2048 integers):
- _hive2K_not(__hi32s *a, __hi32s *b)
- Performs NOT operation in elements of source vector A and stores the result
- into the destination vector B.
-
- 32-bit Mask (64 integers):
- _hive64_masks(__hi32s *a, __hi32s *b, __hi32s *c)
- Inserts each signed element of source vector A into the destination vector C
- if the corresponding element of the source vector B is 0, otherwise it leaves
- the destination vector unchanged.
-
- 32-bit Mask (2048 integers):
- _hive2K_masks(__hi32s *a, __hi32s *b, __hi32s *c)
- Inserts each signed element of source vector A into the destination vector C
- if the corresponding element of the source vector B is 0, otherwise it leaves
- the destination vector unchanged.
-
- 32-bit Masku (64 integers):
- _hive64_masku(__hi32u *a, __hi32u *b, __hi32u *c)
- Inserts each unsigned element of source vector A into the destination vector
- C if the corresponding element of the source vector B is 0, otherwise it
- leaves the destination vector unchanged.
-
- 32-bit Masku (2048 integers):
- _hive2K_masku(__hi32u *a, __hi32u *b, __hi32u *c)
- Inserts each unsigned element of source vector A into the destination vector
- C if the corresponding element of the source vector B is 0, otherwise it
- leaves the destination vector unchanged.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- COMPARISON:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Set Less Than (64 integers):
- _hive64_slts(__hi32s *a, __hi32s *b, __hi32s *c)
- Compares each signed element of source vectors A and B and if the element of
- A is minor than the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- 32-bit Set Less Than (2048 integers):
- _hive2K_slts(__hi32s *a, __hi32s *b, __hi32s *c)
- Compares each signed element of source vectors A and B and if the element of
- A is minor than the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- 32-bit Set Less Than Unsigned (64 integers):
- _hive64_sltu(__hi32u *a, __hi32u *b, __hi32u *c)
- Compares each unsigned element of source vectors A and B and if the element
- of A is minor than the element of B, destination source C stores 1 in the
- same position. Otherwise, stores 0.
-
- 32-bit Set Less Than Unsigned (2048 integers):
- _hive2K_sltu(__hi32u *a, __hi32u *b, __hi32u *c)
- Compares each unsigned element of source vectors A and B and if the element
- of A is minor than the element of B, destination source C stores 1 in the
- same position. Otherwise, stores 0.
-
- 32-bit Compare if equal (64 integers):
- _hive64_cmpeqs(__hi32s *a, __hi32s *b, __hi32s *c)
- Compares each signed element of source vectors A and B and if the element of
- A is equal to the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- 32-bit Compare if equal (2048 integers):
- _hive2K_cmpeqs(__hi32s *a, __hi32s *b, __hi32s *c)
- Compares each signed element of source vectors A and B and if the element of
- A is equal to the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- 32-bit Compare if equal Unsigned (64 integers):
- _hive64_cmpequ(__hi32u *a, __hi32u *b, __hi32u *c)
- Compares each unsigned element of source vectors A and B and if the element
- of A is equal to the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- 32-bit Compare if equal Unsigned (2048 integers):
- _hive2K_cmpequ(__hi32u *a, __hi32u *b, __hi32u *c)
- Compares each unsigned element of source vectors A and B and if the element
- of A is equal to the element of B, destination source C stores 1 in the same
- position. Otherwise, stores 0.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- SHIFT:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Shift Left Logical (64 integers):
- _hive64_sll(__hi32u *a, __hi32u *b, __hi32u *c)
- Left shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- does not shift signal.
-
- 32-bit Shift Left Logical (2048 integers):
- _hive2K_sll(__hi32u *a, __hi32u *b, __hi32u *c)
- Left shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- does not shift signal.
-
- 32-bit Shift Right Logical (64 integers):
- _hive64_srl(__hi32u *a, __hi32u *b, __hi32u *c)
- Right shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- does not shift signal.
-
- 32-bit Shift Right Logical (2048 integers):
- _hive2K_srl(__hi32u *a, __hi32u *b, __hi32u *c)
- Right shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- does not shift signal.
-
- 32-bit Shift Right Arithmetic (64 integers):
- _hive64_sra(__hi32s *a, __hi32s *b, __hi32s *c)
- Right shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- shifts signal.
-
- 32-bit Shift Right Arithmetic (2048 integers):
- _hive2K_sra(__hi32s *a, __hi32s *b, __hi32s *c)
- Right shifts each element in source vector A the amount specified in source
- vector B and stores the result into the destination vector C. This operation
- shifts signal.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- MULTIPLICATION/DIVISION:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Divide Only (64 integers):
- _hive64_divs(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed division between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Divide Only (2048 integers):
- _hive2K_divs(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed division between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Divide Only Unsigned (64 integers):
- _hive64_divu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned division between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Divide Only Unsigned (2048 integers):
- _hive2K_divu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned division between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Module Only (64 integers):
- _hive64_mods(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed module operation between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Module Only (2048 integers):
- _hive2K_mods(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed module operation between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Module Only Unsigned (64 integers):
- _hive64_modu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned module operation between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Module Only Unsigned (2048 integers):
- _hive2K_modu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned module operation between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Multiply (64 integers):
- _hive64_mults(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed multiplication between elements of source vectors A and B and
- stores the result into the destination vector C.
-
- 32-bit Multiply (2048 integers):
- _hive2K_mults(__hi32s *a, __hi32s *b, __hi32s *c)
- Performs signed multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Multiply Unsigned (64 integers):
- _hive64_multu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 32-bit Multiply Unsigned (2048 integers):
- _hive2K_multu(__hi32u *a, __hi32u *b, __hi32u *c)
- Performs unsigned multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 64-bit Multiply (32 integers):
- _hive32_mults(__hi64s *a, __hi64s *b, __hi64s *c)
- Performs signed multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 64-bit Multiply (1024 integers):
- _hive1K_mults(__hi64s *a, __hi64s *b, __hi64s *c)
- Performs signed multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 64-bit Multiply Unsigned (32 integers):
- _hive32_multu(__hi64u *a, __hi64u *b, __hi64u *c)
- Performs unsigned multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- 64-bit Multiply Unsigned (1024 integers):
- _hive1K_multu(__hi64u *a, __hi64u *b, __hi64u *c)
- Performs unsigned multiplication between elements of source vectors A and B
- and stores the result into the destination vector C.
-
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- IMMEDIATE:
- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
- 32-bit Move Immediate Data:
- _hive64_movs(__hi32s *a, __hi32s *b)
- Replicates a signed immediate b into the vector A.
-
- 32-bit Move Immediate Data (2048 integers):
- _hive2K_movs(__hi32s *a, __hi32s *b)
- Replicates a signed immediate b into the vector A.
-
- 32-bit Move Immediate Data Unsigned (64 integers):
- _hive64_movu(__hi32u *a, __hi32u *b)
- Replicates a unsigned immediate b into the vector A.
-
- 32-bit Move Immediate Data (2048 integers):
- _hive2K_movu(__hi32u *a, __hi32u *b)
- Replicates a unsigned immediate b into the vector A.
